vec4 load(vec3 p, float f) 
{
    if (min(p.x,min(p.y,p.z)) < 0.0)
        return vec4(0.0);
        
   	if (max(p.x,max(p.y,p.z)) >= (R / pow(2.0,f)))
        return vec4(0.0);
        
    vec2 uv = vec2(float(int(p.z)) * R + p.x, f * R + p.y);  
    
    return texture(iChannel0, uv / iChannelResolution[0].xy);
}

bool cube(vec3 org, vec3 dir, out float near, out float far) {
    vec3 p = -org/dir;
    vec3 q = 0.5/abs(dir);
	vec3 tmin = p - q;
	vec3 tmax = p + q;
    near = max(tmin.x,max(tmin.y,tmin.z));
	far = min(tmax.x,min(tmax.y,tmax.z));
	return near < far && far > 0.0;
}

vec2 rotate(vec2 p, float a) {
    float c = cos(a);
    float s = sin(a);
    return vec2(
    	p.x * c + p.y * s,
    	p.x * s - p.y * c );
}

vec3 hue2rgb (float hue) {
    return clamp(abs(mod(hue * 6.0 + vec3(0.0,4.0,2.0),6.0) - 3.0) - 1.0,0.0,1.0);
}

// maps n=0 to blue, n=1 to red, n=0.5 to green
vec3 normhue (float n)  {
    return hue2rgb((1.0 - clamp(n,0.0,1.0)) * 0.66667);
}

void mainImage( out vec4 fragColor, in vec2 fragCoord )
{
    // Normalized pixel coordinates (from 0 to 1)
    vec2 uv = fragCoord/iResolution.xy;
    fragColor = vec4(0.0);

    float a = iTime * 0.1;
    vec2 ndc = ((uv * 2.0) - 1.0) * 0.5;
    ndc.x *= iResolution.x / iResolution.y;
    
    vec3 rayOrigin    = vec3(0.0, 0.0, -2.0);
    vec3 rayDirection = vec3(ndc, 1.0);

    float tStart; // o + d * tStart = entry into the volume
    float tStop;  // o + d * tStop  = exit from the volume
    
    // test against volume bounds
    if (cube(rayOrigin, rayDirection, tStart, tStop)) 
    {
        const int   N     = 128;            // number of steps to take
        const float S     = 1.0 / float(N); // size of each step
        float       range = tStop - tStart; // length of the path through the volume

        // march through the volume
        for (int i = 1; i < N; ++i)
        {
            float t   = tStart + (range * float(i) * S); 
            vec3  p   = rayOrigin + rayDirection * t + 0.5;
	        vec4  c   = load(p * R, 0.0);
            
            // hit a filled voxel
            if (distance(p, vec3(0.0)) < 0.5)
            {
                fragColor = vec4(vec3(c) * t * 2.0, 1.0);
                return;
            }
        }
    }
}